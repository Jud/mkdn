# Design Decisions: Directory Sidebar Navigation

**Feature ID**: directory-sidebar
**Created**: 2026-02-16

## Decision Log

| ID | Decision | Choice | Rationale | Alternatives Considered |
|----|----------|--------|-----------|------------------------|
| D1 | Window routing type | `LaunchItem` enum with `.file(URL)` / `.directory(URL)` | Explicit intent at the type level; clean WindowGroup routing via `WindowGroup(for: LaunchItem.self)`; avoids runtime URL inspection heuristics; user-selected approach | (A) Single `WindowGroup(for: URL.self)` with `url.hasDirectoryPath` check -- simpler but implicit and couples detection into window creation; (B) Separate `WindowGroup` per type -- verbose, duplicates configuration |
| D2 | Sidebar layout approach | Custom HStack-based layout with manual divider | CON-3 requirement explicitly mandates this; compatible with `.hiddenTitleBar` window style used by the app; full control over divider behavior, animation, and hit target | `NavigationSplitView` -- rejected per CON-3 due to hidden title bar incompatibility and limited customization control |
| D3 | Directory state ownership | New `DirectoryState` (@Observable, @MainActor) class, separate from `DocumentState` | Clean separation of concerns -- `DocumentState` stays unchanged for single-file mode. `DirectoryState` is `nil` when not in directory mode, so no conditional overhead. Follows established pattern of per-concern state classes (AppSettings, DocumentState, FindState) | Extend `DocumentState` with optional directory fields -- rejected because it would bloat the single-file path and mix concerns |
| D4 | File tree data model | `FileTreeNode` struct (value type, recursive children array) | Efficient SwiftUI diffing via Equatable/Hashable; Sendable for concurrency safety; immutable once built by scanner; tree structure naturally represents filesystem hierarchy | (A) Class-based tree with reference semantics -- poor SwiftUI diffing, unnecessary mutability; (B) Flat array with depth field -- loses structural relationships, complicates tree operations |
| D5 | Directory scanning architecture | Pure static function `DirectoryScanner.scan(url:maxDepth:)` in an enum namespace | Fully testable without side effects or mocks; can be called synchronously (fast for expected file counts per NFR-1); clean separation from state management | (A) Instance method on DirectoryState -- mixes scanning with state; (B) Async actor -- unnecessary overhead for synchronous FileManager calls on expected file counts |
| D6 | Directory watching scope | Root directory + first-level subdirectories only | Matches v1 scope (CON-1); bounded resource usage (max ~N+1 file descriptors where N is first-level subdirectory count); covers the most common modification scenarios | (A) Full recursive watching -- unbounded file descriptor count, potential resource exhaustion on deep trees; (B) Root directory only -- would miss file additions in subdirectories |
| D7 | Sidebar width persistence | Not persisted in v1; resets to default 240pt per window | Simplicity for v1; per-window state naturally resets on window close; no cross-session expectation for sidebar width. Can add UserDefaults persistence (keyed by directory path) in a later iteration | UserDefaults persistence -- deferred, not needed for v1 acceptance criteria |
| D8 | Tree rendering strategy | Flatten visible nodes into a flat list for `LazyVStack` | `LazyVStack` provides view virtualization for large trees (NFR-2); flat list with depth-based indentation is simpler than recursive SwiftUI views; expansion state controls which nodes appear in the flat list | (A) Recursive `ForEach` with `DisclosureGroup` -- SwiftUI `DisclosureGroup` has limited customization and does not support lazy loading; (B) `List` with `children:` parameter -- limited styling control, conflicts with sidebar background customization |
| D9 | Welcome view adaptation | `isDirectoryMode` environment key (default `false`) read by existing `WelcomeView` | Minimal change to existing view; backward-compatible default preserves single-file behavior; environment key is set by `DirectoryContentView` wrapper | (A) Separate `DirectoryWelcomeView` -- code duplication; (B) Init parameter on `WelcomeView` -- requires changes at all call sites |
| D10 | DirectoryState-to-DocumentState communication | Weak reference (`weak var documentState: DocumentState?`) | Simple, direct; matches per-window lifecycle where both exist together; no overhead of notification/publisher infrastructure; weak reference avoids retain cycles | (A) NotificationCenter -- too indirect for a known 1:1 relationship; (B) Combine publisher -- project uses @Observable, not Combine; (C) Callback closure -- equivalent complexity without the clarity of a direct reference |
| D11 | Sidebar show/hide animation | `gentleSpring` resolved through `MotionPreference` | Sidebar toggle is a layout transition, same category as view mode switch which already uses `gentleSpring`; respects Reduce Motion (resolves to `reducedInstant`); feels weighted but not bouncy | (A) `crossfade` -- too subtle for a spatial position change; (B) `springSettle` -- too bouncy for structural layout changes; both rejected for design language consistency |
| D12 | Selection highlight style | Theme accent color at 0.2 opacity as row background | Finder-like sidebar convention; uses existing `ThemeColors.accent` (Solarized blue); 0.2 opacity is subtle enough to not overwhelm the Solarized palette while remaining clearly visible | (A) Full accent color background -- too visually dominant in Solarized; (B) Underline indicator -- non-standard for sidebar trees; (C) Leading border accent -- less discoverable |
| D13 | LaunchContext extension approach | Parallel `directoryURLs` array + `MKDN_LAUNCH_DIR` env var | Mirrors existing `fileURLs` + `MKDN_LAUNCH_FILE` pattern exactly; keeps file and directory paths separate across the `execv` boundary; clear intent | (A) Encode type prefix in `MKDN_LAUNCH_FILE` (e.g., `dir:` prefix) -- fragile string convention; (B) Single `LaunchItem` array in LaunchContext -- would require Codable serialization across execv boundary |
| D14 | DirectoryWatcher restart strategy | Restart watcher with updated subdirectory list on tree refresh | Handles newly created first-level subdirectories being watched; clean slate avoids stale file descriptors for deleted directories; simple implementation | (A) Incrementally add/remove watchers -- more complex, error-prone tracking of which subdirectories are new vs removed; (B) Never restart -- misses watching newly created subdirectories |
