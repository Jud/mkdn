# Design Decisions: Custom Find Bar

**Feature ID**: custom-find-bar
**Created**: 2026-02-15

## Decision Log

| ID | Decision | Choice | Rationale | Alternatives Considered |
|----|----------|--------|-----------|------------------------|
| D1 | Find bar hosting layer | SwiftUI overlay in ContentView ZStack | Achieves z-order requirement (above all overlays including ModeTransitionOverlay, TheOrbView) naturally via ZStack ordering. Matches the existing pattern used by ModeTransitionOverlay. Pure SwiftUI avoids manual NSView frame management. | (a) NSHostingView overlay on NSTextView -- would require manual z-order management vs OverlayCoordinator entries, sticky headers, and code block copy buttons; (b) NSPanel floating window -- over-engineered for a single in-window overlay |
| D2 | State architecture | Dedicated `FindState` @Observable class, separate from DocumentState | Single Responsibility Principle: DocumentState manages file lifecycle; FindState manages find UI state. Prevents DocumentState from growing with unrelated concerns. Per-window ownership follows DocumentState pattern. | (a) Embed find state in DocumentState -- violates SRP, couples file and find concerns; (b) @State in FindBarView -- inaccessible from menu commands via FocusedValue |
| D3 | Search execution location | Coordinator calls `findState.performSearch(in: textStorage.string)` in updateNSView | Ensures search always runs against the actual rendered text storage content, not raw markdown. The Coordinator is the only component with access to the text storage. Explicit method call avoids didSet chains and gives precise control over timing. | (a) FindState.query didSet triggers search on stored searchableText -- creates bidirectional data flow between FindState and Coordinator, risk of update loops; (b) FindState searches documentState.markdownContent -- would search raw markdown (with # symbols, etc.) instead of rendered text |
| D4 | Highlight mechanism | TextKit 2 `NSTextLayoutManager.setRenderingAttributes(_:for:)` | Visual-only attributes that do not modify the text storage. No undo registration, no attributed string mutation, no impact on print or copy operations. Clean separation between document content and find UI. | (a) Modify NSTextStorage attributes directly -- mutates the document content, requires careful cleanup, affects undo stack; (b) Custom drawing in drawBackground(in:) -- would require CodeBlockBackgroundTextView to know about find state, adding coupling |
| D5 | Menu integration pattern | `@FocusedValue(\.findState)` in MkdnCommands | Directly parallels the existing `@FocusedValue(\.documentState)` pattern for per-window state access from the Commands struct. Established codebase convention. | (a) Static/shared find state -- breaks per-window isolation; (b) Find commands dispatch via NSApp.sendAction -- loses type safety, requires NSObject selector dispatch |
| D6 | NSTextFinder disposition | Full removal (remove usesFindBar, isIncrementalSearchingEnabled, performFindPanelAction calls) | The custom find bar completely replaces NSTextFinder functionality. Keeping both would create conflicting behaviors (two find UIs, competing highlights, ambiguous Cmd+F target). Clean replacement eliminates the conflict. | (a) Keep NSTextFinder as fallback -- creates two competing find systems; the stock find bar would still appear if any code path calls performFindPanelAction |
| D7 | SwiftUI <-> Coordinator communication | Pass individual find properties as SelectableTextView parameters | SwiftUI's @Observable tracking requires property-level access during view body evaluation to trigger updateNSView. Passing `findQuery`, `findCurrentIndex`, `findIsVisible` as value parameters ensures SwiftUI calls updateNSView when any of these change. The Coordinator detects changes by comparing to tracked last-applied values. | (a) Pass only FindState object reference -- SwiftUI may not track individual property changes if no properties are read during body evaluation, risking missed updateNSView calls; (b) Coordinator uses withObservationTracking -- requires recursive re-registration, more complex lifecycle management |
| D8 | Find bar position | Top-right corner of preview viewport, fixed position | Per requirements (FR-07). Does not displace content (FR-05). Matches mental model of find bars in browsers and editors. The top-right avoids conflict with the mode transition overlay (centered) and the orb (bottom-right). | (a) Top-center -- conflicts with ModeTransitionOverlay position; (b) Bottom-right -- would be obscured by or conflict with TheOrbView |
| D9 | Focus return on dismiss | Coordinator calls `makeFirstResponder(textView)` when findIsVisible transitions to false | Ensures keyboard focus returns to the text view for immediate arrow-key scrolling per FR-02. The Coordinator is the natural place for this since it owns the text view reference. | (a) FindBarView's onDisappear calls makeFirstResponder -- FindBarView doesn't have access to the NSTextView; (b) Separate notification/callback -- over-engineered for a simple focus transfer |
| D10 | Animation delegation | FindBarView manages its own entrance/exit animation via @State isPresented + transition | Matches ModeTransitionOverlay pattern exactly. The parent (ContentView) uses `if findState.isVisible` with `.transition()`, and `withAnimation` is called from the show/dismiss call sites (MkdnCommands). | (a) ContentView manages animation state -- adds unnecessary indirection; the existing ModeTransitionOverlay pattern proves this approach works |
