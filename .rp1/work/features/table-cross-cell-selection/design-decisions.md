# Design Decisions: Table Cross-Cell Selection

**Feature ID**: table-cross-cell-selection
**Created**: 2026-02-23

## Decision Log

| ID | Decision | Choice | Rationale | Alternatives Considered |
|----|----------|--------|-----------|------------------------|
| D1 | Table text representation in NSTextStorage | Invisible text with clear foreground + TableAttributes | Enables native TextKit 2 selection, find, and clipboard without changing visual rendering. Table text participates in the document's text flow, enabling cross-block selection continuity (FR-002) and Cmd+A (FR-003). | (a) Keep NSTextAttachment placeholder, add separate selection tracking layer -- breaks cross-block continuity because the attachment is a single character that doesn't represent cell-level content; (b) Make table text visible and remove SwiftUI overlay -- would require recreating all visual styling (alternating rows, header background, rounded borders, column widths) in NSAttributedString, which has no native table support |
| D2 | Visual rendering approach | Keep existing TableBlockView SwiftUI overlay unchanged | Zero visual regression risk (FR-007). The overlay provides pixel-identical rendering. The visual layer is decoupled from the selection/interaction layer, following the principle of additive change. | (a) Rebuild table visuals in CodeBlockBackgroundTextView.drawBackground -- high effort, fragile alignment between AppKit drawing and SwiftUI's layout engine; (b) Use NSAttributedString paragraph styles with tab stops for visual rendering -- insufficient for rounded borders, header backgrounds, and alternating row colors |
| D3 | Selection highlight mechanism | Separate NSView (TableHighlightOverlay) positioned on top of the visual overlay | Direct AppKit drawing provides 16ms response time (NFR-001). No SwiftUI state plumbing required -- the overlay coordinator updates the view directly. hitTest returns nil for full event passthrough (FR-011). | (a) SwiftUI overlay within TableBlockView using @Observable selected cells state -- requires reactive state bridge from NSTextView delegate through coordinator to SwiftUI, adds latency and complexity; (b) CALayer overlay -- less control over NSBezierPath drawing, harder to synchronize with scroll position; (c) Draw in NSTextView's drawBackground -- hidden under the TableBlockView overlay |
| D4 | Cell geometry mapping storage | TableCellMap as NSObject subclass stored via NSAttributedString attribute | Follows the established CodeBlockAttributes/CodeBlockColorInfo pattern. Single source of truth accessible anywhere the text storage is available. Supports O(log n) cell lookup via binary search (NFR-003). Memory overhead is O(rows x cols) per table (NFR-004). | (a) OverlayCoordinator computes geometry on demand from column widths and row heights -- duplicates computation, requires passing column data separately; (b) Global dictionary keyed by table ID -- violates per-document isolation, requires cleanup |
| D5 | Clipboard format | RTF as primary pasteboard type, tab-delimited plain text as fallback | Directly specified in requirements (FR-004). RTF covers rich text editors (TextEdit, Pages). Tab-delimited covers spreadsheets (Numbers, Excel). Both placed on pasteboard simultaneously so target application selects the richest format it supports. | (a) Markdown pipe-separated format -- not specified in requirements, less useful for the two primary paste targets; (b) HTML table -- heavier format, less universal clipboard support on macOS; (c) Plain text only -- loses table structure in rich text editors |
| D6 | Find highlight for table cells | Draw find highlights in TableHighlightOverlay, not via text storage backgroundColor | The visual overlay (NSHostingView) is opaque and sits on top of the NSTextView. Text storage background color changes underneath are not visible. The TableHighlightOverlay draws find highlights at cell level on top of the visual overlay, ensuring matches are visually highlighted (FR-006). | (a) Adjust overlay z-order to show text storage highlights through the overlay -- would require making the overlay semi-transparent or using blend modes, breaking visual parity (FR-007); (b) Use TextKit 2 rendering attributes -- these don't trigger cached layout fragment re-rendering |
| D7 | Entrance animation grouping | Extend existing blockGroupID method to detect TableAttributes.range alongside CodeBlockAttributes.range | Minimal change to existing code. Tables and code blocks both need fragment grouping for unified entrance animation (FR-009). Using the same mechanism ensures consistent animation timing and behavior. | (a) Separate table-specific entrance animation system -- unnecessary divergence from the established code block pattern; (b) No animation grouping for tables -- would result in per-line-fragment stagger within a table, looking broken |
| D8 | Print table rendering | Visible foreground in text + drawBackground container rendering | When isPrint is true, the builder uses visible foreground instead of clear. CodeBlockBackgroundTextView.drawBackground draws table containers (rounded rect, header background, alternating rows) only during print -- mirroring how code block containers are drawn. Screen rendering continues to use the SwiftUI overlay. | (a) Separate print view builder -- unnecessary duplication of the table text generation logic; (b) Capture SwiftUI overlay as image for print -- complex, loses text quality at print resolution |
| D9 | Text-range overlay positioning in OverlayCoordinator | Extend OverlayEntry with optional tableRangeID, position by scanning text storage for TableAttributes.range | Reuses the existing OverlayCoordinator infrastructure. Attachment-based overlays (Mermaid, images, thematic breaks) continue to work unchanged. Table overlays use text-range-based positioning via layout fragment enumeration -- the same technique used by CodeBlockBackgroundTextView.fragmentFrames(). | (a) Replace all overlays with text-range positioning -- unnecessary disruption to working attachment-based overlays; (b) Separate coordinator for table overlays -- violates the single-coordinator pattern, complicates sticky header management |
| D10 | Cell-level selection granularity implementation | Snap selection to cell boundaries in textViewDidChangeSelection, draw whole-cell highlights | The NSTextView performs character-level selection natively. The coordinator detects when selection intersects table text, maps to cell positions via TableCellMap, and the highlight overlay draws full-cell highlights. The actual NSTextView selection range is not modified (to avoid interfering with copy behavior), only the visual highlight is cell-level. | (a) Override setSelectedRange to snap to cell boundaries -- would interfere with Shift-click extend and other selection interactions; (b) Draw character-level highlights matching NSTextView selection -- out of V1 scope per requirements |
