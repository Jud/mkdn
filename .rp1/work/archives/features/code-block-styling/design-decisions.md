# Design Decisions: Code Block Styling

**Feature ID**: code-block-styling
**Created**: 2026-02-09

## Decision Log

| ID | Decision | Choice | Rationale | Alternatives Considered |
|----|----------|--------|-----------|------------------------|
| D1 | Background drawing mechanism | Custom `NSTextView.drawBackground(in:)` override | Preserves text selection (FR-10, Must Have), integrates natively with TextKit 2 layout geometry, no overlay complexity. `drawBackground(in:)` is called during the standard drawing cycle, after layout is complete, so fragment frames are available for bounding rect computation. | (a) NSTextAttachment + NSHostingView overlay: would reuse existing overlay pattern and get SwiftUI container for free, but code block text would not be part of NSTextView's text storage, breaking cross-block text selection (FR-10). (b) NSTextLayoutFragment subclass: would allow per-fragment custom drawing, but coordinating a single rounded rect across multiple fragments is fragile and requires custom NSTextContentManager delegation. (c) Keep per-run .backgroundColor: current approach; cannot produce rounded corners, padding, or border. |
| D2 | Code block range marking | Custom `NSAttributedString.Key` (.codeBlockRange) | Standard AppKit mechanism for tagging text ranges with metadata. Attributes are stored in the text storage, survive editing operations, and are enumerable during drawing. The drawing code discovers code block regions by enumerating this key, with no external state coupling. | (a) External range tracking array maintained alongside the attributed string: fragile, must be kept in sync across content updates, theme changes, and text storage mutations. (b) Custom NSTextStorage subclass that tracks code block ranges: overkill for this use case and breaks the current architecture where MarkdownTextStorageBuilder produces plain NSAttributedString instances. |
| D3 | Color passing to drawing code | `CodeBlockColorInfo` object stored as `.codeBlockColors` attribute | The drawBackground override needs background and border colors without referencing external state (AppState, theme). Storing resolved NSColor values directly in the attributed string makes the drawing code self-contained and theme-safe. When the theme changes, the attributed string is rebuilt with new colors. | (a) Look up the current theme from a global/environment reference during drawing: couples the NSTextView subclass to AppState, creates a dependency that's hard to test and fragile across theme transitions. (b) Hardcode colors: violates BR-1 (no hardcoded color literals) and breaks theme switching. |
| D4 | Container padding mechanism | `NSParagraphStyle` headIndent/firstLineHeadIndent/tailIndent | TextKit natively supports paragraph-level indentation. Setting headIndent (left) and tailIndent (right, negative value) on code block paragraphs creates real whitespace between the text content and the container edge. The drawing code then draws the rounded rect at the un-indented text container boundary, and the text appears padded inside it. | (a) Inset the drawing rect instead of indenting the text: the text would still render flush against the container edge; the "padding" would be visual only in the background, not reflected in the text layout. Text touching the container edge violates FR-2. (b) textContainerInset: applies to all content globally, not just code blocks. |
| D5 | Horizontal scrolling (FR-8, Should Have) | Deferred -- code lines soft-wrap within the container | FR-10 (text selection, Must Have) takes priority. Horizontal scrolling of individual code blocks within a single NSTextView text flow is not feasible without breaking the unified text storage that enables cross-block selection. Code lines will wrap at the container width. This is acceptable for initial delivery. The SwiftUI `CodeBlockView` (secondary path) already supports horizontal scrolling and can serve as a reference for future enhancement. | (a) Per-code-block NSHostingView overlay with ScrollView: provides horizontal scrolling but breaks text selection across code block boundaries. (b) Make the entire NSTextView horizontally scrollable: affects all content, not just code blocks, creating a poor reading experience for prose. |
| D6 | Container width extent | Full width of text container (minus small inset) | FR-1 specifies "extends the full width of the content area." This matches GitHub, VS Code, and Obsidian code block rendering. Consistent width across all code blocks regardless of line length creates a clean, predictable layout. | (a) Shrink-to-fit the longest code line: inconsistent widths across code blocks, looks unpolished, harder to compute. |
| D7 | Corner radius | 6pt | Matches the existing `CodeBlockView.swift` SwiftUI implementation (cornerRadius: 6) and the `htmlBlock` rendering in `MarkdownBlockView` (cornerRadius: 6). This is the established convention in the codebase. | (a) 8pt: rounder, but no existing precedent in the codebase. (b) 4pt: too subtle to distinguish from a sharp corner at normal viewing distance. |
| D8 | SpacingConstants reference | Use existing `MarkdownTextStorageBuilder` static constants | The requirements reference "SpacingConstants" but this type does not exist in the codebase. The `MarkdownTextStorageBuilder` already defines spacing as static `CGFloat` constants (blockSpacing: 12, codeLabelSpacing: 4, etc.). Following the existing pattern avoids introducing a new abstraction that would be used by only one consumer. A new constant for container padding (12pt) will be added to the builder's constants section. | (a) Create a new `SpacingConstants` file: scope creep beyond this feature, no existing consumers, would need to migrate all existing spacing constants. |

## AFK Mode: Auto-Selected Technology Decisions

| Decision | Choice | Source | Rationale |
|----------|--------|--------|-----------|
| Drawing API | AppKit Core Graphics (NSBezierPath) | Codebase pattern | The rendering pipeline is entirely AppKit-based (NSTextView, NSAttributedString). No SwiftUI drawing context is available in `drawBackground(in:)`. |
| NSTextView subclass location | `mkdn/Features/Viewer/Views/` | Codebase pattern | All viewer-related views live in `Features/Viewer/Views/`. The subclass is a view-layer component. |
| CodeBlockAttributes location | `mkdn/Core/Markdown/` | Codebase pattern | Attribute keys are part of the Markdown rendering pipeline. All text storage builder support types live in `Core/Markdown/`. |
| Test framework | Swift Testing (@Suite, @Test, #expect) | KB patterns.md | Project mandate: Swift Testing for all unit tests. |
| Container padding value | 12pt | Codebase convention | Matches `CodeBlockView` padding (`.padding(12)`), consistent with visual density of existing layout. |
| Border opacity | 0.3 | Codebase convention | Matches `CodeBlockView` border opacity (`.stroke(colors.border.opacity(0.3))`). |
| FR-8 resolution | Defer horizontal scrolling, use soft wrap | Conservative default | Must Have FR-10 (text selection) conflicts with Should Have FR-8 (horizontal scroll) within a single NSTextView. Conservative choice preserves the higher-priority requirement. |
| Code block ID generation | UUID string per appendCodeBlock call | Conservative default | Simple, unique, no collision risk. The ID only needs to group characters within one code block; it is not persisted or referenced externally. |
