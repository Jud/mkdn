# Design Decisions: Fix Infinite Scroll Re-render Loop

**Feature ID**: fix-infinite-scroll-rerender
**Created**: 2026-02-06

## Decision Log

| ID | Decision | Choice | Rationale | Alternatives Considered |
|----|----------|--------|-----------|------------------------|
| D1 | Where to cache rendered NSImages | Separate `@MainActor` `MermaidImageStore` singleton | `NSImage` is not `Sendable` and cannot be stored in the `MermaidRenderer` actor without isolation violations. A `@MainActor` class matches the view lifecycle since view `init` and `body` run on MainActor. Keeps rendering concern separate from central `AppState`. | (a) Store in `MermaidRenderer` actor -- isolation mismatch with NSImage. (b) Store in `AppState` -- pollutes central state with rendering implementation detail. (c) Store in `@Environment` observable -- adds complexity without benefit since singleton access is simpler. |
| D2 | How to prevent loading-state flicker on recycled views | Synchronous cache check in `MermaidBlockView.init`, initialize `@State` from cache | SwiftUI `@State` initial values are set at view creation time, before `.task` fires. This is the only way to start a recycled view in its fully-rendered state without showing even one frame of loading placeholder. The loading placeholder has a different height than the rendered diagram, which is what triggers the LazyVStack re-layout cascade. | (a) Replace `LazyVStack` with `VStack` -- avoids recycling entirely but breaks performance for large documents (NFR-1). (b) Check cache inside `.task` only -- `.task` is async, so the view renders at least one frame with `isLoading = true` before the task can update state, still causing a layout shift. |
| D3 | Keep LazyVStack vs switch to VStack | Keep `LazyVStack` | `LazyVStack` provides necessary scroll performance for documents with 100+ blocks (NFR-1). The re-render bug is caused by the view lifecycle management (`.task` re-firing, loading state transitions), not by lazy loading itself. Fixing the lifecycle is the correct approach. | `VStack` -- simpler and eliminates view recycling, but creates all views upfront, which for large documents with many Mermaid blocks would cause a long initial load time and high memory usage. |
| D4 | `.task` vs `.task(id:)` modifier | Use `.task(id: code)` | `.task(id:)` fires on first appear AND when the `id` value changes. This means if the parent view body re-evaluates (e.g., unrelated state change) but the mermaid `code` is unchanged, the task does not re-fire. With plain `.task`, the task re-fires on every appear including after SwiftUI internally destroys and recreates the view body. Using `.task(id: code)` also provides automatic re-render when mermaid source code changes in the editor. | Plain `.task` -- fires on every view appear, including parent body re-evaluations, contributing to unnecessary work. |
| D5 | `ListItem` identity strategy | Content-derived stable ID (hash of child block IDs) | Current `UUID()` regenerates a new identity on every call to `MarkdownRenderer.render()`. Since `MarkdownPreviewView` calls render on content change and theme change, every render pass gives all list items new UUIDs. SwiftUI's `ForEach` diff algorithm sees all items as new, destroys all existing list item views, and creates new ones. This causes unnecessary work and can interact with the Mermaid re-render cycle if list items contain or are adjacent to Mermaid blocks. Content-based IDs ensure stability across identical render passes. | (a) UUID -- current approach, unstable. (b) Array index -- fragile if items are reordered or inserted/deleted. |
| D6 | NSImage cache capacity | 50 entries (matching SVG cache) | Typical technical documents contain 1-10 Mermaid diagrams. A capacity of 50 provides generous headroom. Each NSImage is typically 100KB-1MB depending on diagram complexity, so worst case is approximately 50MB -- reasonable for a desktop application. The LRU eviction policy ensures the most recently viewed diagrams stay cached. | (a) Unlimited -- risk of unbounded memory growth for pathological documents. (b) 10 -- too small; would evict diagrams in a moderately large document, causing re-renders on scroll-back. |
| D7 | `ImageBlockView` fix approach | `.task(id: source)` + early return guard, optional `ImageStore` for full cache | Images are significantly cheaper to load than Mermaid diagrams (no JavaScript execution, no SVG rasterization). The early return guard in `.task` prevents the re-render cycle at minimal cost. A full `ImageStore` cache is structurally identical to `MermaidImageStore` and can be added later if images prove to be a scroll-back issue in practice. | (a) Full `ImageStore` singleton -- more code, smaller marginal benefit. (b) No change -- leaves a potential (though less severe) re-render issue for images. |
| D8 | Cache invalidation strategy | Clear-all on file load and theme change; per-block via `.task(id: code)` | File reload may change any or all Mermaid blocks, so clearing the entire NSImage cache is the safe approach. Theme changes may affect SVG rendering (colors, fonts), so the image cache must be invalidated. Per-block invalidation is automatic: `.task(id: code)` fires when `code` changes, and the new code's hash naturally misses the cache. | (a) Time-based expiry -- unnecessary complexity for a desktop app with explicit load/save lifecycle. (b) Never invalidate -- risk of showing stale diagrams after content changes. (c) Per-block content-diff invalidation -- more complex, no benefit over the `.task(id:)` approach. |
